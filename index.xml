<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SnowFox</title>
    <link>https://arcticnature.github.io/</link>
    <description>Recent content on SnowFox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>Copyright (c) 2015, Stefano Pogliani</copyright>
    <lastBuildDate>Sat, 10 Sep 2016 00:03:00 +0100</lastBuildDate>
    <atom:link href="https://arcticnature.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Node configuration</title>
      <link>https://arcticnature.github.io/references/lua/node-config/</link>
      <pubDate>Sat, 10 Sep 2016 00:03:00 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lua/node-config/</guid>
      <description>

&lt;p&gt;SnowFox nodes are configured through an extensible LUA interface.
This is the core set of options and values provided.&lt;/p&gt;

&lt;h2 id=&#34;the-core-object&#34;&gt;The &lt;code&gt;core&lt;/code&gt; object&lt;/h2&gt;

&lt;p&gt;A snow-fox node requres a few options to be set and allows many
other to be tuned.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;core&lt;/code&gt; object collects all configuration options that relate to
the fundamental functioning of a node rather than a specific
feature of snow-fox.&lt;/p&gt;

&lt;p&gt;This section provides a list of options provided in the official
snow-fox distribution.
Remember that components can extend these options so check the
documentation of any additional or modified component you use.&lt;/p&gt;

&lt;h3 id=&#34;core-event-manager&#34;&gt;&lt;code&gt;core.event_manager&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;As SnowFox is an event-based system with an asynchronous run loop
(similar to how node.js works) it needs a way to know if any
of its configured sources has received an event.&lt;/p&gt;

&lt;p&gt;The event manager is what looks after all the sources and determines
when one of them has an event that needs to be handled.&lt;/p&gt;

&lt;p&gt;The default value of &lt;code&gt;event_managers.epoll&lt;/code&gt; should work for most
cases and should only be changed by users that understand the
implementation of the event managers in the code.&lt;/p&gt;

&lt;h3 id=&#34;core-logger&#34;&gt;&lt;code&gt;core.logger&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;By default SnowFox logs to standard output and standard error.
The logging configuration can be changed by creating a new logger
with the desired options.&lt;/p&gt;

&lt;p&gt;Allowed values for this options are picked from the &lt;code&gt;loggers&lt;/code&gt;
collection and the options of each logger is documented there.&lt;/p&gt;

&lt;h3 id=&#34;core-events-from-source&#34;&gt;&lt;code&gt;core.events_from(source)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Register an event source for use by the new configuration.
An event source is one of the &lt;code&gt;sources&lt;/code&gt; with their configuration.&lt;/p&gt;

&lt;p&gt;See the definition of each of the availale of &lt;code&gt;sources&lt;/code&gt; for what
they do and what options are available.&lt;/p&gt;

&lt;h2 id=&#34;the-connectors-object&#34;&gt;The &lt;code&gt;connectors&lt;/code&gt; object&lt;/h2&gt;

&lt;p&gt;Connectors are SnowFox way to interface with processes.
This means how processes start, stop, restart, etc &amp;hellip;
Different connectors&amp;rsquo; configurations are stored in the &lt;code&gt;connectors&lt;/code&gt;
object.&lt;/p&gt;

&lt;p&gt;See individual &lt;code&gt;connectors&lt;/code&gt; for details of the available options.&lt;/p&gt;

&lt;h3 id=&#34;connectors-local&#34;&gt;&lt;code&gt;connectors[&amp;quot;local&amp;quot;]&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;local&lt;/code&gt; connector is the interface to the local host processes.
Uses &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;execve&lt;/code&gt; to create new processes and signals to
interact with them.&lt;/p&gt;

&lt;h2 id=&#34;global-functions&#34;&gt;Global functions&lt;/h2&gt;

&lt;p&gt;Not all configuration options can be described with one value
or a list of values so components can define extra interfaces
to the user by means of LUA functions.&lt;/p&gt;

&lt;p&gt;Below is the list of functions that are registered by core components.&lt;/p&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
  &lt;p&gt;No global function is available at this time.&lt;/p&gt;

&lt;/div&gt;


&lt;h2 id=&#34;available-event-managers&#34;&gt;Available &lt;code&gt;event_managers&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Below is a list of available event manager.&lt;/p&gt;

&lt;h3 id=&#34;event-managers-epoll&#34;&gt;&lt;code&gt;event_managers.epoll&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This uses the
&lt;a href=&#34;http://man7.org/linux/man-pages/man7/epoll.7.html&#34;&gt;epoll kernel feature&lt;/a&gt;
to watch for events on the configured event sources.&lt;/p&gt;

&lt;h2 id=&#34;available-loggers&#34;&gt;Available &lt;code&gt;loggers&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Different loggers target different backends.
By default SnowFox uses the &lt;code&gt;console&lt;/code&gt; logger to output events to
stdout and stderr to ensure that early messages reach the user.&lt;/p&gt;

&lt;p&gt;The following special values are used to configure the logging level:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INFO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WARNING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;loggers-console&#34;&gt;&lt;code&gt;loggers.console&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Writes &lt;code&gt;DEBUG&lt;/code&gt; and &lt;code&gt;INFO&lt;/code&gt; messages to standard output
and &lt;code&gt;WARNING&lt;/code&gt; and &lt;code&gt;ERROR&lt;/code&gt; messages to standard error.&lt;/p&gt;

&lt;h3 id=&#34;loggers-null&#34;&gt;&lt;code&gt;loggers.null&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Drop all log messages.&lt;/p&gt;

&lt;h2 id=&#34;available-sources&#34;&gt;Available &lt;code&gt;sources&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Sources are the starting point of all activity in SnowFox.
Different features either register their own sources or register
events with either the &lt;code&gt;ManualSource&lt;/code&gt; or the &lt;code&gt;ScheduledSource&lt;/code&gt;
which are always available.&lt;/p&gt;

&lt;h3 id=&#34;sources-scheduler&#34;&gt;&lt;code&gt;sources.scheduler&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Configure the &lt;code&gt;SchedulerSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Events are enqueued with a delay after which the event should be handled.
Delays are expressed as multiple of &lt;code&gt;tick&lt;/code&gt;s so that speeding up or
down instances can be acieved easly.
This avoids implementation guessing a delay that does not overload
the system and let the user tune delays.&lt;/p&gt;

&lt;p&gt;The following options can be passed to configure the source:&lt;/p&gt;

&lt;div class=&#34;mdtable table-striped&#34;&gt;
  &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Default&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tick&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Seconds in a &lt;code&gt;tick&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>LUA client API</title>
      <link>https://arcticnature.github.io/references/lua/client/</link>
      <pubDate>Mon, 23 May 2016 22:06:59 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lua/client/</guid>
      <description>

&lt;p&gt;LUA interfaces available in the &lt;code&gt;snow-fox-client&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;global-names&#34;&gt;Global names&lt;/h2&gt;

&lt;p&gt;The following names are available in the global scope.&lt;/p&gt;

&lt;h3 id=&#34;clear&#34;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Clears the terminal window and show the promp on the top line.&lt;/p&gt;

&lt;h3 id=&#34;pprint-value&#34;&gt;&lt;code&gt;pprint(value)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Prints the &lt;code&gt;value&lt;/code&gt; argument.
If &lt;code&gt;value&lt;/code&gt; is a LUA table, &lt;code&gt;pprint&lt;/code&gt; recursively prints the keys
and their values.&lt;/p&gt;

&lt;h3 id=&#34;print&#34;&gt;&lt;code&gt;print(...)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Prints the given arguments, separating them with a &lt;code&gt;\t&lt;/code&gt; (TAB).&lt;/p&gt;

&lt;h2 id=&#34;the-client-object&#34;&gt;The &lt;code&gt;client&lt;/code&gt; object&lt;/h2&gt;

&lt;p&gt;Commands that interact with the client are availale through the
&lt;code&gt;client&lt;/code&gt; global object.&lt;/p&gt;

&lt;h3 id=&#34;client-exit&#34;&gt;&lt;code&gt;client:exit()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Causes the client to exit cleanly.&lt;/p&gt;

&lt;h3 id=&#34;client-version&#34;&gt;&lt;code&gt;client:version()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Returns a LUA table with the client version information.
The table has the following fields:&lt;/p&gt;

&lt;div class=&#34;mdtable table-striped&#34;&gt;
  &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Field&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Decription&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Client&amp;rsquo;s SemVer&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0.0.3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Git hash&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ece936dd1f349fd9d0b31dbb9098cb204e5e8ff5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;taint&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Git state at build time&lt;/td&gt;
&lt;td&gt;&lt;code&gt;git index tainted&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;


&lt;h2 id=&#34;the-node-object&#34;&gt;The &lt;code&gt;node&lt;/code&gt; object&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;snow-fox-client&lt;/code&gt; connects to a &lt;code&gt;snow-fox&lt;/code&gt; node at start time.
The &lt;code&gt;node&lt;/code&gt; global object allows to interact with the specific node
connected at start up.&lt;/p&gt;

&lt;h3 id=&#34;node-status-callback-details&#34;&gt;&lt;code&gt;node:status(callback[, details])&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Requests the status of the node.&lt;/p&gt;

&lt;p&gt;When the node returns the status information, the &lt;code&gt;callback&lt;/code&gt; is invoked
with the result converted into a LUA table.&lt;/p&gt;

&lt;p&gt;If the optional &lt;code&gt;details&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt; (defaults to &lt;code&gt;false&lt;/code&gt;)
then the node includes detailed information about itself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Event based system</title>
      <link>https://arcticnature.github.io/references/advanced/events/</link>
      <pubDate>Tue, 17 May 2016 20:47:54 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/advanced/events/</guid>
      <description>

&lt;p&gt;SnowFox is an event based system.
&lt;code&gt;Event&lt;/code&gt;s are created by different &lt;code&gt;EventSource&lt;/code&gt;s.&lt;br /&gt;
Each &lt;code&gt;snow-fox-*&lt;/code&gt; process configures an &lt;code&gt;EventSourceManager&lt;/code&gt; and the
relevant &lt;code&gt;EventSource&lt;/code&gt;s and enters the event loop.&lt;/p&gt;

&lt;p&gt;This page descrives the events interface and semantics:&lt;/p&gt;

&lt;h2 id=&#34;event-s-interface&#34;&gt;&lt;code&gt;Event&lt;/code&gt;s interface&lt;/h2&gt;

&lt;p&gt;Events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Are subclasses of the &lt;code&gt;sf::core::model::Event&lt;/code&gt; abstract class.&lt;/li&gt;
&lt;li&gt;Define an handling process (&lt;code&gt;handle&lt;/code&gt; method).&lt;/li&gt;
&lt;li&gt;Can optionally cope with its own failures (&lt;code&gt;rescue&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;Event&lt;/code&gt; interface is defined in
&lt;a href=&#34;https://github.com/ArcticNature/core/blob/master/model/event/include/core/model/event.h&#34;&gt;https://github.com/ArcticNature/core/blob/master/model/event/include/core/model/event.h&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sharing-state&#34;&gt;Sharing state&lt;/h2&gt;

&lt;p&gt;Events can be given parameters when they are created by the event source
that creates them but they cannot otherwise interact with future events.&lt;/p&gt;

&lt;p&gt;This means that an event generated as a response to another event cannot
access the context in which the original event was created.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;snow-fox-client&lt;/code&gt; provides the &lt;code&gt;node.status()&lt;/code&gt; method.
Here is what happens when the user calls this method:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The client returns a pending response to the user.&lt;/li&gt;
&lt;li&gt;The client sends a request to the SnowFox node serving it.&lt;/li&gt;
&lt;li&gt;The node processes the request and determines the state.&lt;/li&gt;
&lt;li&gt;The node sends the state back to the client.&lt;/li&gt;
&lt;li&gt;The client processes the response and resolves the pending response.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;But how does the client know which pending response to resolve?
While &lt;code&gt;Event&lt;/code&gt; instances represent independent events across the system,
they are related to one another as they aim to acomplish the same goal.&lt;/p&gt;

&lt;p&gt;Events that relate to one another share the same &lt;code&gt;correlation_id&lt;/code&gt;.
When the client receives a status response, it can use the &lt;code&gt;correlation_id&lt;/code&gt;
to figure out which past event triggered the request.&lt;/p&gt;

&lt;p&gt;But that on its own is still not enough to store context.
The &lt;code&gt;sf::core::model::EventContext&lt;/code&gt; template is here to do the rest.
Concrete &lt;code&gt;EventContext&lt;/code&gt;s are maps from &lt;code&gt;correlation_id&lt;/code&gt;s to contexts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Client Lifecycle</title>
      <link>https://arcticnature.github.io/references/lifecycles/cli/</link>
      <pubDate>Sun, 15 May 2016 12:39:44 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lifecycles/cli/</guid>
      <description>

&lt;p&gt;SnowFox client lifecycle events.&lt;/p&gt;

&lt;h2 id=&#34;client-lua-init&#34;&gt;&lt;code&gt;client::lua::init&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Called when the LUA environment for the client is initialised.
The environment is available in &lt;code&gt;sf::core::context::Client::lua()&lt;/code&gt;
for handlers to manipulate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuration Lifecycles</title>
      <link>https://arcticnature.github.io/references/lifecycles/config/</link>
      <pubDate>Sun, 15 May 2016 12:39:44 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lifecycles/config/</guid>
      <description>

&lt;p&gt;SnowFox configuration lifecycles for node, cluster.&lt;/p&gt;

&lt;h2 id=&#34;nodeconfiglifecyclearg&#34;&gt;&lt;code&gt;NodeConfigLifecycleArg&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Argument passed to &lt;code&gt;config::node::*&lt;/code&gt; events to provide access to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sf::core::interface::NodeConfigLoader* loader()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sf::core::utility::Lua* lua()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;config-node-collect&#34;&gt;&lt;code&gt;config::node::collect&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;After the configuration files have been executed this event is
triggered to collect configuration intents from the LUA environment
and add them to the configuration loader.&lt;/p&gt;

&lt;h2 id=&#34;config-node-init-lua&#34;&gt;&lt;code&gt;config::node::init-lua&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Initialise the Lua environment for a NodeConfigLoader.
This handler should be used by components to provide an interface
to the users to configure the components themselves.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>snow-fox-client</title>
      <link>https://arcticnature.github.io/references/cli/client/</link>
      <pubDate>Mon, 11 Apr 2016 22:39:59 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/cli/client/</guid>
      <description>

&lt;p&gt;The official command line client.
Used to interact with the SnowFox server.&lt;/p&gt;




&lt;h2 id=&#34;other&#34;&gt;Other&lt;/h2&gt;

&lt;p&gt;Miscellaneous options.&lt;/p&gt;

&lt;h3 id=&#34;help-show-available-options&#34;&gt;&lt;code&gt;--help&lt;/code&gt;: show available options&lt;/h3&gt;

&lt;p&gt;Print the list of available options and parameters and exits.&lt;/p&gt;

&lt;h3 id=&#34;version-show-version-and-exit&#34;&gt;&lt;code&gt;--Version&lt;/code&gt;: show version and exit&lt;/h3&gt;

&lt;p&gt;Print the version of the binary and exits.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node status codes</title>
      <link>https://arcticnature.github.io/references/advanced/status/system/</link>
      <pubDate>Sat, 09 Apr 2016 22:48:34 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/advanced/status/system/</guid>
      <description>

&lt;p&gt;This is a list of node status codes.&lt;/p&gt;

&lt;h3 id=&#34;unkown&#34;&gt;&lt;code&gt;UNKOWN&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The state of the node could not be fully determined.&lt;/p&gt;

&lt;h3 id=&#34;ok&#34;&gt;&lt;code&gt;OK&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The node is up and running!&lt;/p&gt;

&lt;h3 id=&#34;process-ready&#34;&gt;&lt;code&gt;PROCESS_READY&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The initialisation of the process hosting the node is complete.&lt;/p&gt;

&lt;h3 id=&#34;warning&#34;&gt;&lt;code&gt;WARNING&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Something is not as desired.&lt;/p&gt;

&lt;h3 id=&#34;process-starting&#34;&gt;&lt;code&gt;PROCESS_STARTING&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The process hosting the node is starting up.&lt;/p&gt;

&lt;h3 id=&#34;error&#34;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The node is in error state.&lt;/p&gt;

&lt;h3 id=&#34;end&#34;&gt;&lt;code&gt;END&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Placeholder for the last valid node status code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Representing status</title>
      <link>https://arcticnature.github.io/references/advanced/status/</link>
      <pubDate>Sat, 09 Apr 2016 09:38:16 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/advanced/status/</guid>
      <description>&lt;p&gt;SnowFox keeps track not only of itself but also the services it
runs, depends on, or other items defined by extensions.
To avoid users/admins insanity, all these status information is
presented in a consistent way.&lt;/p&gt;

&lt;p&gt;Status information is formed of two bits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Traffic light overview:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Red: the unit is confirmed to be in an undesired state
(failed process, invalid configuration, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;Yellow: the unit is not in the desired state but that may not
be an issue (system starting, configuration loading, &amp;hellip;).&lt;/li&gt;
&lt;li&gt;Green: the unit is in the desired state.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Status details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An exact status code for the unit.&lt;/li&gt;
&lt;li&gt;A human readable message with the reason for the status.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This format allows to quickly check the overall system and to derive
aggregate status overviews while keeping the details needed to react
to issue in the system itself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Change log</title>
      <link>https://arcticnature.github.io/page/changelog/</link>
      <pubDate>Thu, 07 Apr 2016 22:18:41 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/page/changelog/</guid>
      <description>

&lt;h2 id=&#34;undetermined&#34;&gt;Undetermined&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TODO(stefano): Daemon and Spawner log through the manager.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Logger configuration.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Log level filtering.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Spawner and Daemon configuration.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Spawner and Daemon event manager.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-7&#34;&gt;0.0.7&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TODO(stefano): Service registry.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-6&#34;&gt;0.0.6&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TODO(stefano): TOPIC: Metadata storage&lt;/li&gt;
&lt;li&gt;TODO(stefano): Metadata store model.&lt;/li&gt;
&lt;li&gt;TODO(stefano): SQLite (local) metadata store.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Node metadata store.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Node metadata store configuration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-5&#34;&gt;0.0.5&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TODO(stefano): TOPIC: Events refactoring.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Introduce &lt;code&gt;Reactor&lt;/code&gt;s (to react to state change).&lt;/li&gt;
&lt;li&gt;TODO(stefano): Refactor &lt;code&gt;EventSourceManager&lt;/code&gt; to &lt;code&gt;IoManager&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Introduce static &lt;code&gt;EventSource&lt;/code&gt;s.&lt;/li&gt;
&lt;li&gt;TODO(stefano): Refactor &lt;code&gt;EventDrain&lt;/code&gt; to support buffering and async flushes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-4&#34;&gt;0.0.4&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create/Migrate ScheduledSources during reconfig.&lt;/li&gt;
&lt;li&gt;Git backed repository.&lt;/li&gt;
&lt;li&gt;Initial configuration loading.&lt;/li&gt;
&lt;li&gt;Migrate Managers&amp;rsquo;s sources (spawner and daemon).&lt;/li&gt;
&lt;li&gt;Migrate ManaualSource during reconfig.&lt;/li&gt;
&lt;li&gt;Node configuration and example repo.&lt;/li&gt;
&lt;li&gt;Node configuration loader.&lt;/li&gt;
&lt;li&gt;Return configuration version with node&amp;rsquo;s status.&lt;/li&gt;
&lt;li&gt;ScheduledSource configuration.&lt;/li&gt;
&lt;li&gt;Support event manager reconfiguration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-3&#34;&gt;0.0.3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Client introduction.&lt;/li&gt;
&lt;li&gt;Event contexts.&lt;/li&gt;
&lt;li&gt;Lua interface to client API.&lt;/li&gt;
&lt;li&gt;Lua interface to node API.&lt;/li&gt;
&lt;li&gt;Manager&amp;rsquo;s event registry.&lt;/li&gt;
&lt;li&gt;Node status request.&lt;/li&gt;
&lt;li&gt;Node status response.&lt;/li&gt;
&lt;li&gt;Promised events.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-2&#34;&gt;0.0.2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Command line client started.&lt;/li&gt;
&lt;li&gt;Fixed daemon termination with Ctrl+C in console mode.&lt;/li&gt;
&lt;li&gt;Fixed undetected client disconnects.&lt;/li&gt;
&lt;li&gt;LUA utility wrapper classes.&lt;/li&gt;
&lt;li&gt;Manual event source.&lt;/li&gt;
&lt;li&gt;Node name from command line.&lt;/li&gt;
&lt;li&gt;Node name used in event ids.&lt;/li&gt;
&lt;li&gt;Print binary version and exit.&lt;/li&gt;
&lt;li&gt;Public protocol started.&lt;/li&gt;
&lt;li&gt;Scheduled event source.&lt;/li&gt;
&lt;li&gt;Started cluster interface.&lt;/li&gt;
&lt;li&gt;Status definition and helpers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-1&#34;&gt;0.0.1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Event ids and correlation ids.&lt;/li&gt;
&lt;li&gt;Improved event handler registration at static initialisation time.&lt;/li&gt;
&lt;li&gt;Version header file.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-0-0&#34;&gt;0.0.0&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Core framework.&lt;/li&gt;
&lt;li&gt;Process orchestration and daemonisation.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Lifecycle</title>
      <link>https://arcticnature.github.io/references/lifecycles/event/</link>
      <pubDate>Sun, 03 Apr 2016 10:36:08 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lifecycles/event/</guid>
      <description>

&lt;p&gt;Extend and customise events as they move across SnowFox.&lt;/p&gt;




&lt;h2 id=&#34;eventlifecyclearg&#34;&gt;&lt;code&gt;EventLifecycleArg&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;EventLifecycleArg&lt;/code&gt; is a &lt;code&gt;BaseLifecycleArg&lt;/code&gt; that stores
a reference to an &lt;code&gt;Event&lt;/code&gt; instance.
It is passed to &lt;code&gt;event::*&lt;/code&gt; lifecycle events that require an
&lt;code&gt;Event&lt;/code&gt; instance to operate on.&lt;/p&gt;

&lt;h2 id=&#34;event-identify&#34;&gt;&lt;code&gt;event::_identify&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A special step in the lifecycle of an event that is triggered
just after an event is created but before the &lt;code&gt;event::initialise&lt;/code&gt;
step.&lt;/p&gt;

&lt;p&gt;This step generates the id (and possibly the correlation id) of an
&lt;code&gt;Event&lt;/code&gt; instance.
The &lt;code&gt;Event&lt;/code&gt; reference to operate on is passed to the handler in an
&lt;code&gt;EventLifecycleArg&lt;/code&gt; instance.&lt;/p&gt;

&lt;p&gt;Every component that instantiates an object should use the
&lt;code&gt;sf::core::lifecycle::EventLifecycle::Init&lt;/code&gt; method to ensure the
event is initialised correctly.&lt;/p&gt;

&lt;h2 id=&#34;event-initialise&#34;&gt;&lt;code&gt;event::initialise&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This step is triggered when an &lt;code&gt;Event&lt;/code&gt; is initialised and identified.
The &lt;code&gt;Event&lt;/code&gt; reference to operate on is passed to the handler in an
&lt;code&gt;EventLifecycleArg&lt;/code&gt; instance.&lt;/p&gt;

&lt;p&gt;Every component that instantiates an object should use the
&lt;code&gt;sf::core::lifecycle::Event::Initialise&lt;/code&gt; method to ensure the
event is initialised correctly.&lt;/p&gt;



</description>
    </item>
    
    <item>
      <title>Process Lifecycle</title>
      <link>https://arcticnature.github.io/references/lifecycles/process/</link>
      <pubDate>Sun, 03 Apr 2016 10:34:39 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lifecycles/process/</guid>
      <description>

&lt;p&gt;React to the running process evolution and events.&lt;/p&gt;

&lt;h2 id=&#34;process-init&#34;&gt;&lt;code&gt;process::init&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Triggered when the process is started.
Used primarily by modules to initialise or register features with the system.&lt;/p&gt;

&lt;h3 id=&#34;registering-an-handler&#34;&gt;Registering an handler&lt;/h3&gt;

&lt;p&gt;Registering a &lt;code&gt;process::init&lt;/code&gt; handler is a special task because the
registration must occur during static initialisation, a phase where
the initialisation order is &amp;hellip; fuzzy.&lt;/p&gt;

&lt;p&gt;To help with that the &lt;code&gt;sf::core::lifecycle::Process::Initialiser&lt;/code&gt;
template can be used to register the &lt;code&gt;process::init&lt;/code&gt; handler.
In one of the component&amp;rsquo;s source files, add the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BaseLifecycleHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BaseLifecycleArg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lifecycle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MyModuleInitialiser&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BaseLifecycleHandler&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BaseLifecycleArg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Initialisation code here ...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Initialiser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyModuleInitialiser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_module_initialiser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class=&#34;alert alert-danger&#34; role=&#34;alert&#34;&gt;
  &lt;p&gt;Keep in mind that static order initialisation is non-deterministic.
As such,
&lt;strong&gt;it is not possible to know in which order &lt;code&gt;process::init&lt;/code&gt; handlers run&lt;/strong&gt;!&lt;/p&gt;

&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;process-exit&#34;&gt;&lt;code&gt;process::exit&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Triggered when the SnowFox process is terminated.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lifecycles Reference</title>
      <link>https://arcticnature.github.io/references/lifecycles/</link>
      <pubDate>Sun, 03 Apr 2016 10:24:12 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/lifecycles/</guid>
      <description>

&lt;p&gt;Part of the flexibility and extensibility of SnowFox comes from Lifecycles.
Lifecycles are a way to react to internal system events and decouple
handing of actions.
The component system also relies on Lifecycles to dynamically inject features
and alternative implementations.&lt;/p&gt;

&lt;p&gt;Lifecycles revolve around the &lt;code&gt;sf::core::interface::Lifecycle&lt;/code&gt; class,
which behaves in a similar manner to Node.js event emitter.&lt;/p&gt;

&lt;p&gt;All events are registered and triggered on the same &lt;code&gt;Lifecycle&lt;/code&gt;
singleton instance throughout the system.
Name spaces in the event name are used to avoid conflicts with context.&lt;/p&gt;

&lt;h2 id=&#34;lifecycle-api&#34;&gt;Lifecycle API&lt;/h2&gt;

&lt;p&gt;Interactions with the Lifecycles system can be divided into two:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Event handling: the side that reacts to changes in the system.&lt;/li&gt;
&lt;li&gt;Event triggering: the side that informs lifecycles of a change.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Checkout the Lifecycle interface in the source code at
&lt;a href=&#34;https://github.com/ArcticNature/core/blob/master/interface/lifecycle/include/core/interface/lifecycle.h&#34;&gt;https://github.com/ArcticNature/core/blob/master/interface/lifecycle/include/core/interface/lifecycle.h&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;example-acting-at-process-initialisation&#34;&gt;Example: acting at process initialisation&lt;/h3&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//! Example of Lifecycle event handler.&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ExampeInitHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BaseLifecycleHandler&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BaseLifecycleArg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Some code that needs to run when the process starts.&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;


&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// Register the handler.&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;LifecycleHandlerRef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExampeInitHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Lifecycle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;process::init&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// Some init logic ...&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// Trigger the `process::init` event.&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Lifecycle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trigger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;process::init&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;list-of-official-lifecycles&#34;&gt;List of official Lifecycles&lt;/h2&gt;

&lt;p&gt;Events are nothing more then strings that identify a list of handlers.
Lifecycles are a sequence of these events triggered by the system.
There is no formal checking or definition of lifecycles.&lt;/p&gt;

&lt;p&gt;While the system (and components in it) can create their own lifecycles,
this section of the reference pages describes the lifecycles
part of the core components of SnowFox.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Daemon/Manager Messages Reference</title>
      <link>https://arcticnature.github.io/references/protobuf/dm/messages/</link>
      <pubDate>Fri, 01 Apr 2016 23:28:11 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/protobuf/dm/messages/</guid>
      <description>

&lt;p&gt;Below is the list of messages exchanged between the Daemon and the Manager:&lt;/p&gt;

&lt;h2 id=&#34;message-code&#34;&gt;&lt;code&gt;Message::Code&lt;/code&gt;&lt;/h2&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core.protocol.daemon_manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Code&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;na&#34;&gt;Ack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;na&#34;&gt;Shutdown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class=&#34;mdtable table-striped&#34;&gt;
  &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ack&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;This message is an acknowledgement of a request&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Shutdown&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Request the manager process to shutdown&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Daemon/Manager Protocol Reference</title>
      <link>https://arcticnature.github.io/references/protobuf/dm/protocol/</link>
      <pubDate>Fri, 01 Apr 2016 23:28:11 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/protobuf/dm/protocol/</guid>
      <description>

&lt;h2 id=&#34;system-shutdown&#34;&gt;System Shutdown&lt;/h2&gt;

&lt;p&gt;The system shutdown can be initiated from the daemon by:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A user&amp;rsquo;s sending &lt;code&gt;SIGTERM&lt;/code&gt; to the daemon.&lt;/li&gt;
&lt;li&gt;The manager subprocess terminating.&lt;/li&gt;
&lt;li&gt;The spawner subprocess terminating.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In any of the above cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The daemon sends a &lt;code&gt;Message&lt;/code&gt; with code &lt;code&gt;Message::Code::Shutdown&lt;/code&gt;
to the manager, if it is not dead.&lt;/li&gt;
&lt;li&gt;The manager performs the shutdown actions and terminates.&lt;/li&gt;
&lt;li&gt;The daemon detects that the manager terminated.&lt;/li&gt;
&lt;li&gt;The daemon sends a &lt;code&gt;Message&lt;/code&gt; with code &lt;code&gt;Message::Code::Shutdown&lt;/code&gt;
to the spawner, if it is not dead.&lt;/li&gt;
&lt;li&gt;The spawner performs the shutdown actions and terminates.&lt;/li&gt;
&lt;li&gt;The daemon terminates.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Daemon/Spawner Messages Reference</title>
      <link>https://arcticnature.github.io/references/protobuf/ds/messages/</link>
      <pubDate>Fri, 01 Apr 2016 23:28:11 +0100</pubDate>
      
      <guid>https://arcticnature.github.io/references/protobuf/ds/messages/</guid>
      <description>

&lt;p&gt;Below is the list of messages exchanged between the Daemon and the Spawner:&lt;/p&gt;

&lt;h2 id=&#34;message-code&#34;&gt;&lt;code&gt;Message::Code&lt;/code&gt;&lt;/h2&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;core.protocol.daemon_spanwer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Code&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;na&#34;&gt;Ack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;na&#34;&gt;Shutdown&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class=&#34;mdtable table-striped&#34;&gt;
  &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ack&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;This message is an acknowledgement of a request&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Shutdown&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Request the spawner process to shutdown&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>